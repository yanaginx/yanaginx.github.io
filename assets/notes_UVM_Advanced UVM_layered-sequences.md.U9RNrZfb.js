import{_ as t,c as a,a2 as n,o as s}from"./chunks/framework.CbP2pKAi.js";const o="/assets/Untitled.DCLx8AZm.png",l="/assets/Untitled%201.4H3aSUfB.png",i="/assets/Untitled%202.D4sO061_.png",r="/assets/Untitled%203.CsW6CJoB.png",c="/assets/Untitled%204.CdWGh4-E.png",u="/assets/Untitled%205.fn47sVY6.png",p="/assets/Untitled%206.ljWhkHuS.png",d="/assets/Untitled%207.DYIPs4Xp.png",h="/assets/Untitled%208.D68zPkQ9.png",m="/assets/Untitled%209.CnyZAEMa.png",q="/assets/Untitled%2010.BQK7pQLU.png",g="/assets/Untitled%2011.Bso9wbKd.png",b="/assets/Untitled%2012.BVYlAuGP.png",y="/assets/Untitled%2013.WyzJ7m7G.png",_="/assets/Untitled%2014.CeAC4JA7.png",v="/assets/Untitled%2015.cTkIRfOv.png",k="/assets/Untitled%2016.DjE112U_.png",U="/assets/Untitled%2017.DhYzvfA2.png",f="/assets/Untitled%2018.CbcZ7dq0.png",x="/assets/Untitled%2019.BdQZ-Pu-.png",P="/assets/Untitled%2020.Dq1LHf6N.png",w="/assets/Untitled%2021.GJE76JEY.png",C="/assets/Untitled%2022.9Z3NIGK4.png",S="/assets/Untitled%2023.DwBKICrW.png",T="/assets/Untitled%2024.CLqU8eDk.png",A="/assets/Untitled%2025.b4S-2iSq.png",M="/assets/Untitled%2026.CC1nKosh.png",V="/assets/Untitled%2027.By7e2tR9.png",L="/assets/Untitled%2028.-TDjk29Q.png",D="/assets/Untitled%2029.BJbyuO6r.png",W=JSON.parse('{"title":"Layered Sequences","description":"","frontmatter":{"slug":"layered-sequences"},"headers":[],"relativePath":"notes/UVM/Advanced UVM/layered-sequences.md","filePath":"notes/UVM/Advanced UVM/layered-sequences.md","lastUpdated":1727526443000}'),B={name:"notes/UVM/Advanced UVM/layered-sequences.md"};function I(E,e,z,H,G,J){return s(),a("div",null,e[0]||(e[0]=[n('<h1 id="layered-sequences" tabindex="-1">Layered Sequences <a class="header-anchor" href="#layered-sequences" aria-label="Permalink to &quot;Layered Sequences&quot;">​</a></h1><blockquote><p>Contents are extracted from the Advanced UVM sessions by <a href="https://verificationacademy.com/" target="_blank" rel="noreferrer">Verification Academy</a>.</p></blockquote><h2 id="sequences-and-sequencers" tabindex="-1">Sequences and sequencers <a class="header-anchor" href="#sequences-and-sequencers" aria-label="Permalink to &quot;Sequences and sequencers&quot;">​</a></h2><p><em>Most sequences run on sequences</em></p><ul><li>One sequencer per agent</li><li>Env may define default sequence</li><li>Can be overridden via factory</li><li>Test defines other sequences</li></ul><p><em>Sequences generate items</em></p><ul><li>Sequencer send the items to the driver</li></ul><p><em>Tests require coordinating multiple sequences on multiple DUT interfaces (virtual sequencers)</em></p><h2 id="virtual-sequences" tabindex="-1">Virtual sequences <a class="header-anchor" href="#virtual-sequences" aria-label="Permalink to &quot;Virtual sequences&quot;">​</a></h2><p><img src="'+o+'" alt="Untitled"></p><blockquote><p>Only manages the execution of other sequences</p></blockquote><p><img src="'+l+'" alt="Untitled"></p><blockquote><p>Do the sequencer’s handle passing from the test since only the test know the hierarchical path to the sequencer</p></blockquote><p><img src="'+i+'" alt="Untitled"></p><blockquote><p>Start <code>vseq</code> with <code>null</code> sequencer since it doesn’t need to be executed on any sequencer</p></blockquote><h3 id="initialization" tabindex="-1">Initialization <a class="header-anchor" href="#initialization" aria-label="Permalink to &quot;Initialization&quot;">​</a></h3><p><img src="'+r+'" alt="Untitled"></p><blockquote><p><code>init_vseq</code>: Method to initialize the virtual sequence handles (the sequencer handles)</p><p>Calling in <code>run_phase</code></p></blockquote><h3 id="using-virtual-sequence-in-a-test" tabindex="-1">Using virtual sequence in a test <a class="header-anchor" href="#using-virtual-sequence-in-a-test" aria-label="Permalink to &quot;Using virtual sequence in a test&quot;">​</a></h3><blockquote><p>Extends the base test for reusability</p></blockquote><blockquote><p><code>start</code> method of the virtual sequence will execute the <code>body</code> task → Starting sequences in any fashion defined</p></blockquote><p><img src="'+c+'" alt="Untitled"></p><p><img src="'+u+'" alt="Untitled"></p><h2 id="use-virtual-sequencer-as-alternative" tabindex="-1">Use virtual sequencer as alternative <a class="header-anchor" href="#use-virtual-sequencer-as-alternative" aria-label="Permalink to &quot;Use virtual sequencer as alternative&quot;">​</a></h2><p><img src="'+p+'" alt="Untitled"></p><blockquote><p>Since the virtual sequencer is a component, the passing sub-sequencer handling to the virtual sequencer occurs on the <code>connect_phase</code></p></blockquote><p><img src="'+d+'" alt="Untitled"></p><h3 id="virtual-sequence-base" tabindex="-1">Virtual sequence base <a class="header-anchor" href="#virtual-sequence-base" aria-label="Permalink to &quot;Virtual sequence base&quot;">​</a></h3><blockquote><p>Also includes the handle to the virtual sequencer it’s going to be started on</p></blockquote><p><img src="'+h+'" alt="Untitled"></p><p><img src="'+m+'" alt="Untitled"></p><p><img src="'+q+'" alt="Untitled"></p><h2 id="layered-protocols" tabindex="-1">Layered protocols <a class="header-anchor" href="#layered-protocols" aria-label="Permalink to &quot;Layered protocols&quot;">​</a></h2><p><em>Hierarchical Protocols (PCIe, USB3.0, MIPI LLI..)</em></p><ul><li>Transaction layer</li><li>Transport layer</li><li>Physical layer</li></ul><p><em>Protocol-Independent</em></p><ul><li>Generic layer (e.g. TLM2.0 GP)</li><li>Specific protocol (e.g. AMBA AHB)</li></ul><p><em>All require sequence items to be deconstructed and reconstructed</em></p><ul><li>One-to-many: <ul><li>High-level transaction broken down to many low-level transactions</li></ul></li><li>Many-to-one: <ul><li>Many high level transaction will be used to composed a large low-level transactions</li></ul></li></ul><h3 id="tests-start-sequences" tabindex="-1">Tests start sequences <a class="header-anchor" href="#tests-start-sequences" aria-label="Permalink to &quot;Tests start sequences&quot;">​</a></h3><p><em>Want to execute sequences at the top layer</em></p><ul><li>Test starts sequence on sequencer</li></ul><p><em>Reuse as much as possible</em></p><ul><li>Protocol agent on the bus</li><li>Sequencers/monitors at higher layers</li></ul><p><img src="'+g+'" alt="Untitled"></p><p><img src="'+b+'" alt="Untitled"></p><h3 id="adding-layer" tabindex="-1">Adding layer <a class="header-anchor" href="#adding-layer" aria-label="Permalink to &quot;Adding layer&quot;">​</a></h3><p><em>From “above”, he layer looks like a UVC</em></p><ul><li>Run sequence(s) on sequencer</li><li>Monitor (<code>analysis_port</code>) to report activity</li></ul><p><img src="'+y+'" alt="Untitled"></p><p><img src="'+_+'" alt="Untitled"></p><p><em>Must be able to execute sequences on protocol layer</em></p><p><img src="'+v+'" alt="Untitled"></p><h3 id="translation-sequence" tabindex="-1">Translation sequence <a class="header-anchor" href="#translation-sequence" aria-label="Permalink to &quot;Translation sequence&quot;">​</a></h3><p><em>Translation sequence runs on the lower sequencer</em></p><ul><li>Handles the layering connection</li><li>Converts items between layers</li></ul><blockquote><p><em>Have the handle to the upper level sequencer</em></p></blockquote><blockquote><p><strong>Parameterized by the transaction item of the upper level sequencer</strong></p></blockquote><ul><li>Declare transaction item type of the upper level sequence and transaction item type of the lower level sequence to be sent downstream to the driver</li></ul><p><img src="'+k+'" alt="Untitled"></p><blockquote><p><strong>Translation sequence is a dynamic object → Can’t actually have a port here</strong></p></blockquote><p>⇒ Use the <code>get_next_item</code> method of the sequencer to get the transaction</p><p><img src="'+U+'" alt="Untitled"></p><blockquote><p><em>Do the translation to lower level transaction type as needed and send it to the driver using <code>start_item</code> and <code>finish_item</code> pair</em></p></blockquote><p><img src="'+f+'" alt="Untitled"></p><blockquote><p><em>Signal back to the upper level sequencer by calling <code>item_done()</code> method</em></p></blockquote><p><img src="'+x+'" alt="Untitled"></p><aside><img src="https://www.notion.so/icons/info-alternate_blue.svg" alt="https://www.notion.so/icons/info-alternate_blue.svg" width="40px"> *This can be considered as a component behave like a driver* </aside><h3 id="analysis-path" tabindex="-1">Analysis path <a class="header-anchor" href="#analysis-path" aria-label="Permalink to &quot;Analysis path&quot;">​</a></h3><p>*Each layer uses a <em>reconstruction monitor</em></p><ul><li>The “inverse” of the translation sequence</li><li>Assembles high-level items from lower-level items</li></ul><blockquote><p><em>Connect the <code>analysis_export</code> of the monitor <code>analysis_port</code> of the agent to receive the lower-level transaction</em></p></blockquote><blockquote><p><em>The L1_mon having the analysis port to send out the higher level translated transaction</em></p></blockquote><p><img src="'+P+'" alt="Untitled"></p><blockquote><p>Example can be seen on the UVM Cookbook</p></blockquote><p><img src="'+w+'" alt="Untitled"></p><h3 id="layered-agent" tabindex="-1">Layered agent <a class="header-anchor" href="#layered-agent" aria-label="Permalink to &quot;Layered agent&quot;">​</a></h3><blockquote><p><em>Having the handle of the <code>dut_agent</code> to access its sequencer</em></p></blockquote><p><img src="'+C+'" alt="Untitled"></p><p><img src="'+S+'" alt="Untitled"></p><blockquote><p><strong>Connect phase connecting the analysis port and export of the monitor to the agent’s</strong></p></blockquote><p><img src="'+T+'" alt="Untitled"></p><blockquote><p><em>Run phase starting the translation sequence</em></p><ul><li>Passing the up level sequencer handle (current sequencer of the Layered agent) to the sequence</li><li>Start the sequence on the lower-level sequence (<code>dut_agent</code>)</li></ul></blockquote><p><img src="'+A+'" alt="Untitled"></p><h3 id="the-environment" tabindex="-1">The environment <a class="header-anchor" href="#the-environment" aria-label="Permalink to &quot;The environment&quot;">​</a></h3><blockquote><p><em>Connect components as usual</em></p></blockquote><p><img src="'+M+'" alt="Untitled"></p><blockquote><p><em>Multiple layered</em></p></blockquote><p><img src="'+V+'" alt="Untitled"></p><h3 id="the-multi-layered-agent" tabindex="-1">The multi-layered agent <a class="header-anchor" href="#the-multi-layered-agent" aria-label="Permalink to &quot;The multi-layered agent&quot;">​</a></h3><p><em>Encapsulate as many layers as needed</em></p><p><em>Make intermediate <code>analysis_ports</code> available as needed</em></p><p><em>From “above” it looks just like an agent</em></p><p><img src="'+L+'" alt="Untitled"></p><h3 id="internal-protocol-agent" tabindex="-1">Internal protocol agent <a class="header-anchor" href="#internal-protocol-agent" aria-label="Permalink to &quot;Internal protocol agent&quot;">​</a></h3><p><img src="'+D+'" alt="Untitled"></p><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><p><em>Layering agent</em> has a <em>child sequencer</em> for every non-leaf-level</p><p>*Creates and starts a <em>translation sequence</em> for every non-leaf-level</p><ul><li>Translation sequence will be started on lower-level sequencer</li><li>Translation sequence points back to higher-layer sequencers</li></ul><p>*May include a <em>reconstruction monitor</em> for each non-leaf-level</p><p><em>Must have a handle to the leaf-level protocol agent</em></p><ul><li>Agent may be a child of the UVC or external</li></ul><p>*Should create and connect an <code>analysis_port</code> for each monitor</p><p><em>Will usually have a configuration object associated with the layering agent</em></p>',105)]))}const j=t(B,[["render",I]]);export{W as __pageData,j as default};
