"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[477],{10:n=>{n.exports=JSON.parse('{"blogPosts":[{"id":"uvm-module-access","metadata":{"permalink":"/blog/uvm-module-access","source":"@site/blog/2022-12-29-uvm-module-access/For accessing tops module from class-based compon f0f32d102515407f82fdf2c3ef9b8779.md","title":"Accessing tops module from class-based component in UVM testbench","description":"Overview","date":"2022-12-29T00:00:00.000Z","formattedDate":"December 29, 2022","tags":[{"label":"SystemVerilog","permalink":"/blog/tags/system-verilog"},{"label":"UVM","permalink":"/blog/tags/uvm"}],"readingTime":4.74,"hasTruncateMarker":false,"authors":[{"name":"Duong Van","title":"Design Verification Engineer @ Marvell Vietnam LLC.","url":"https://github.com/yanaginx","imageURL":"https://github.com/yanaginx.png","key":"duongvc"}],"frontMatter":{"slug":"uvm-module-access","title":"Accessing tops module from class-based component in UVM testbench","authors":"duongvc","tags":["SystemVerilog","UVM"]}},"content":"## Overview\\n\\nThe case for the need of this access is inside a UVM Testbench, where the test would generate some randomization on the data and need to access the instantiated module (let say `model` in this case) in the `top`. \\n\\n\x3c!-- One naive solution in my case is using UVM\u2019s configuration database (`uvm_config_db`) to pass down the `model` handle from the top to the test component.\\n\\nThe above solution won\u2019t work since the module cannot be passed inside `uvm_config_db` \\n\\nThis is where the following solution should be useful. --\x3e\\n\\n## The workaround\\n\\nFor the workaround demonstration, a simple UVM testbench generated with [EasierUVM](https://www.doulos.com/knowhow/systemverilog/uvm/easier-uvm) will be used.\\n\\n### Overview of the testbench\\n\\n// Update the graph later with the model\u2019s module\\n\\n![Untitled](For%20accessing%20tops%20module%20from%20class-based%20compon%20f0f32d102515407f82fdf2c3ef9b8779/Untitled.png)\\n\\n### Implementation\\n\\nThe DUT in this case is a simple ALU\u2019s adder\\n\\n```verilog\\nmodule adder (\\n    input  logic [7:0] A,\\n    input  logic [7:0] B,\\n    output logic [8:0] F\\n        );\\n    always_comb\\n        F <= A+B;\\nendmodule\\n```\\n\\nThe module wanted to be accessed from the test is the input generator (this is for demonstration purpose only, for normal UVM testbench this should be implemented as UVM driver-driver BFM pair)\\n\\n```verilog\\nmodule input_model (\\n    input  logic clk,\\n    output logic [7:0] A,\\n    output logic [7:0] B\\n);\\n\\n  logic [7:0] input_pool[*];\\n  int current_index = 0;\\n  int rand_index = 0;\\n  reg [7:0] reg_A;\\n  reg [7:0] reg_B;\\n\\n  // Function to be called for adding randomized input\\n  function void insert_input(logic[7:0] value);\\n    input_pool[current_index++] = value;\\n    $display(\\"INPUT MODEL: Currently inserting: 0x%8x at index %d\\", value, current_index-1);\\n  endfunction : insert_input\\n\\n  always @(posedge clk) begin\\n    assert ( randomize(rand_index) with { rand_index inside {[0:current_index-1]}; }) else \\n    begin\\n      $display(\\"why the fuck can it not randomize properly?\\");\\n    end\\n    $display(\\"Current rand_index: %d\\", rand_index);\\n    $display(\\"Current current_index: %d\\", current_index);\\n    reg_A <= input_pool[rand_index];\\n    reg_B <= input_pool[rand_index];\\n  end\\n\\n  assign A = reg_A;\\n  assign B = reg_B;\\n\\nendmodule : input_model\\n```\\n\\nThe package containing the virtual class extending `uvm_object` \u2192 This will be used in other testbench\u2019s class components\\n\\n```verilog\\npackage backdoor_access_pkg;\\n  import uvm_pkg::*;\\n\\n  virtual class input_model_backdoor extends uvm_pkg::uvm_object;\\n    function new(string name=\\"input_model_backdoor\\");\\n      super.new(name);\\n    endfunction\\n\\n    pure virtual function void insert_input(logic [7:0] value);\\n\\n  endclass : input_model_backdoor\\n\\nendpackage : backdoor_access_pkg\\n```\\n\\nThe wrapper class for the module that extends and implement all the virtual methods of the created virtual class\\n\\n```verilog\\n`include \\"uvm_macros.svh\\"\\nimport uvm_pkg::*;\\nimport backdoor_access_pkg::*;\\n\\nclass backdoor_im extends input_model_backdoor;\\n  \\n  function new(string name=\\"backdoor_im\\");\\n    super.new(name);\\n  endfunction : new \\n\\n  function void insert(logic[7:0] value);\\n    **top_tb.th.model.insert_input(value);**\\n  endfunction : insert\\n            \\nendclass : backdoor_im\\n\\ninitial begin\\n  backdoor_im backdoor_im_i;\\n  backdoor_im_i = new();\\n  uvm_config_db #(uvm_object)::set(uvm_root::get(), \\"*\\", \\"IM_BACKDOOR_ACCESS\\", backdoor_im_i);  \\nend\\n```\\n\\n- Adding the handle to the `uvm_config_db` under `uvm_root::get()` as the parent, `*` as the scope, key string and the handle itself:\\n- Instantiating it in the `top.sv` , (`top_tb.sv` in this example)\\n\\n```verilog\\nmodule top_tb;\\n\\n  timeunit      1ns;\\n  timeprecision 1ps;\\n\\n  `include \\"uvm_macros.svh\\"\\n\\n  import uvm_pkg::*;\\n\\n  import top_test_pkg::*;\\n  import top_pkg::top_config;\\n\\n  // Configuration object for top-level environment\\n  top_config top_env_config;\\n\\n  // Test harness\\n  top_th th();\\n\\n  **`include \\"backdoor_input_model.sv\\"**\\n\\n  initial\\n  begin\\n    // Create and populate top-level configuration object\\n    top_env_config = new(\\"top_env_config\\");\\n    if ( !top_env_config.randomize() )\\n      `uvm_error(\\"top_tb\\", \\"Failed to randomize top-level configuration object\\" )\\n\\n    top_env_config.arith_vif             = th.arith_if_0;\\n    top_env_config.is_active_arith       = UVM_ACTIVE;   \\n    top_env_config.checks_enable_arith   = 1;            \\n    top_env_config.coverage_enable_arith = 1;            \\n\\n    uvm_config_db #(top_config)::set(null, \\"uvm_test_top\\", \\"config\\", top_env_config);\\n    uvm_config_db #(top_config)::set(null, \\"uvm_test_top.m_env\\", \\"config\\", top_env_config);\\n\\n    run_test();\\n  end\\n\\nendmodule\\n```\\n\\nIncluding the packages in the environment (in this case in the agent\u2019s package)\\n\\n```verilog\\npackage arith_pkg;\\n\\n  `include \\"uvm_macros.svh\\"\\n\\n  import uvm_pkg::*;\\n\\timport backdoor_access_pkg::*;\\n\\n  `include \\"arith_trans.sv\\"\\n  `include \\"arith_config.sv\\"\\n  `include \\"arith_driver.sv\\"\\n  `include \\"arith_monitor.sv\\"\\n  `include \\"arith_sequencer.sv\\"\\n  `include \\"arith_coverage.sv\\"\\n  `include \\"arith_agent.sv\\"\\n  `include \\"arith_seq_lib.sv\\"\\n\\nendpackage : arith_pkg\\n```\\n\\nAnd the remaining is to access the module from the test using the virtual class, by fetching the handle from the `uvm_config_db` as an `uvm_object` and cast it to the correct type of the virtual class\\n\\n```verilog\\n`ifndef TOP_TEST_SV\\n`define TOP_TEST_SV\\n\\n// You can insert code here by setting test_inc_before_class in file common.tpl\\n\\nclass top_test extends uvm_test;\\n\\n  `uvm_component_utils(top_test)\\n\\n  // Change made here\\n  top_env m_env;\\n  logic [7:0] rand_input = 0;\\n  // end : Change made here\\n\\n  backdoor_access_pkg::input_model_backdoor backdoor_im_i;\\n  uvm_object backdoor_object_i;\\n\\n  extern function new(string name, uvm_component parent);\\n\\n  extern function void build_phase(uvm_phase phase);\\n\\n  extern task run_phase(uvm_phase phase);\\n\\nendclass : top_test\\n\\nfunction top_test::new(string name, uvm_component parent);\\n  super.new(name, parent);\\nendfunction : new\\n\\nfunction void top_test::build_phase(uvm_phase phase);\\n\\n  m_env = top_env::type_id::create(\\"m_env\\", this);\\n\\n  // Fetching the handle from the uvm_config_db and cast it to the correct type\\n  **if(!uvm_config_db#(uvm_object)::get(uvm_root::get(), \\"\\", \\"IM_BACKDOOR_ACCESS\\", backdoor_object_i))   \\n  begin\\n    `uvm_fatal(\\"TEST\\",\\"Failed to get input model backdoor access object\\")\\n  end\\n  assert($cast(backdoor_im_i, backdoor_object_i)) else begin\\n    `uvm_fatal(\\"ASSERT\\", \\"Dynamic casting backdoor_im_instance failed!\\")\\n  end**\\n\\nendfunction : build_phase\\n\\ntask top_test::run_phase(uvm_phase phase);\\n  $display(\\"Went in the run_phase of the test!\\");\\n  #10;\\n  for (int i = 0; i < 256; ++i) begin\\n    assert (randomize(rand_input));\\n    backdoor_im_i.insert(rand_input);\\n  end\\n  #1000;\\nendtask\\n\\n`endif // TOP_TEST_SV\\n```\\n\\nAlso remember to compile the `.sv` file and packages properly. The compiling sequence should be included in the `compile_questa.do` script.\\n\\nThe result when running the simulation\\n\\n![Untitled](For%20accessing%20tops%20module%20from%20class-based%20compon%20f0f32d102515407f82fdf2c3ef9b8779/Untitled%201.png)\\n\\nThe result when dumping signals, by adding some signals on `top_th.sv` and a little addition on `top_tb.sv` file\\n\\n![Untitled](For%20accessing%20tops%20module%20from%20class-based%20compon%20f0f32d102515407f82fdf2c3ef9b8779/Untitled%202.png)\\n\\n![Untitled](For%20accessing%20tops%20module%20from%20class-based%20compon%20f0f32d102515407f82fdf2c3ef9b8779/Untitled%203.png)\\n\\n![Untitled](For%20accessing%20tops%20module%20from%20class-based%20compon%20f0f32d102515407f82fdf2c3ef9b8779/Untitled%204.png)\\n\\nThis result concludes the ability to manipulate the module that is instantiated on the `top` from a test component in UVM testbench\\n\\nFull testbench can be found [here](https://github.com/yanaginx/uvm-module-access).\\n\\n## Summary\\n\\n- Create a virtual class extending `uvm_object` (for example `VC`)\\n- Create a wrapper *class* for the module that extends and implement all the virtual methods of the created virtual class\\n    - Instantiating it in the `top.sv`\\n    - Adding the handle to the `uvm_config_db` under `uvm_root::get()` as the parent, `*` as the scope, key string and the handle itself:\\n        \\n        \\n        uvm_config_db #(uvm_object)::set(uvm_root::get(), \\"*\\", \\"<KEY>\\", <wrapper_handle>);\\n        \\n        \\n    \\n    > This will ensure the scope of the statement used to call the `top`\'s instantiated module.\\n    > \\n    > \\n    > Meaning the statement `top.<module_name>.<method_name>()` should be valid.\\n    > \\n- The virtual class `VC` mentioned above will be used for the lower level component in the environment hierarchy for accessing the top instantiated module\u2019s methods."}]}')}}]);