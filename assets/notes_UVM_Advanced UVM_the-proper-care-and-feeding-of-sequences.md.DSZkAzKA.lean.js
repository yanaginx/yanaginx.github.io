import{_ as t,c as n,a2 as a,o as s}from"./chunks/framework.CbP2pKAi.js";const o="/assets/Untitled.Y3byAa6l.png",i="/assets/Untitled%201.CYR0fvJy.png",r="/assets/Untitled%202.Cn3Nccxq.png",c="/assets/Untitled%203.D9TYUa5B.png",l="/assets/Untitled%204.BdDIvJuL.png",d="/assets/Untitled%205.BahfVBwb.png",p="/assets/Untitled%206.CXKQGU5k.png",u="/assets/Untitled%207.03D2kn4V.png",h="/assets/Untitled%208.Cp1zUSfp.png",m="/assets/Untitled%209.CEqxpAYt.png",q="/assets/Untitled%2010.CK2xnJnm.png",g="/assets/Untitled%2011.BPtdkHoZ.png",f="/assets/Untitled%2012.BKDln4pu.png",b="/assets/Untitled%2013.C7YcfrG_.png",_="/assets/Untitled%2014.Dqpq78LW.png",k="/assets/Untitled%2015.C6SLmGTv.png",U="/assets/Untitled%2016.B7BZm9Pc.png",v="/assets/Untitled%2017.CIVWUys0.png",y="/assets/Untitled%2018.B-wDNm7Q.png",S="/assets/Untitled%2019.8841CYu-.png",M=JSON.parse('{"title":"The Proper Care and Feeding of Sequences","description":"","frontmatter":{"slug":"the-proper-care-and-feeding-of-sequences"},"headers":[],"relativePath":"notes/UVM/Advanced UVM/the-proper-care-and-feeding-of-sequences.md","filePath":"notes/UVM/Advanced UVM/the-proper-care-and-feeding-of-sequences.md","lastUpdated":1727526443000}'),x={name:"notes/UVM/Advanced UVM/the-proper-care-and-feeding-of-sequences.md"};function P(w,e,C,D,B,V){return s(),n("div",null,e[0]||(e[0]=[a('<h1 id="the-proper-care-and-feeding-of-sequences" tabindex="-1">The Proper Care and Feeding of Sequences <a class="header-anchor" href="#the-proper-care-and-feeding-of-sequences" aria-label="Permalink to &quot;The Proper Care and Feeding of Sequences&quot;">​</a></h1><blockquote><p>Contents are extracted from the Advanced UVM sessions by <a href="https://verificationacademy.com/" target="_blank" rel="noreferrer">Verification Academy</a>.</p></blockquote><h2 id="review" tabindex="-1">Review <a class="header-anchor" href="#review" aria-label="Permalink to &quot;Review&quot;">​</a></h2><p>The sequence is always known to have a name when being instantiated - Good convention</p><p>It is possible to reuse a initiated sequence object every iteration if there is guarantee on how the sequence data changed each iteration</p><p>TLM passing the handle of the sequence, must guarantee if the driver or any other component having the handle either make a copy of the handle or finish processing handle</p><blockquote><p>When <code>start_item</code> returns → Driver is ready to accept the transaction</p></blockquote><blockquote><p><code>finish_item</code> is called to send the transaction after the late randomization</p></blockquote><p><img src="'+o+'" alt="Untitled"></p><blockquote><p>Sequencer is recommended to be declared as a class with factory registration</p></blockquote><h3 id="sequencer-driver-handshake" tabindex="-1">Sequencer/Driver handshake <a class="header-anchor" href="#sequencer-driver-handshake" aria-label="Permalink to &quot;Sequencer/Driver handshake&quot;">​</a></h3><p><img src="'+i+'" alt="Untitled"></p><ul><li>Cases where the driver also receive the response and sequence will be waiting for it:</li></ul><p><img src="'+r+'" alt="Untitled"></p><h3 id="sequence-start" tabindex="-1">Sequence start <a class="header-anchor" href="#sequence-start" aria-label="Permalink to &quot;Sequence start&quot;">​</a></h3><p><em>Starting sequence from the test</em></p><p><img src="'+c+'" alt="Untitled"></p><p><em>Sequence can also be started from the environment also</em></p><blockquote><p>Behave like background/default sequence also</p></blockquote><p><img src="'+l+'" alt="Untitled"></p><hr><h2 id="arbitration-and-responses-in-the-sequencer" tabindex="-1">Arbitration and Responses in the Sequencer <a class="header-anchor" href="#arbitration-and-responses-in-the-sequencer" aria-label="Permalink to &quot;Arbitration and Responses in the Sequencer&quot;">​</a></h2><p><img src="'+d+'" alt="Untitled"></p><p><img src="'+p+'" alt="Untitled"></p><p><img src="'+u+'" alt="Untitled"></p><p><img src="'+h+'" alt="Untitled"></p><p><img src="'+m+'" alt="Untitled"></p><p><img src="'+q+'" alt="Untitled"></p><blockquote><p>Optional: additional response id field to indicate which transaction to be received on the sequence</p><p>Get response call will not return until the transaction with matching transaction id is returned</p></blockquote><blockquote><p>Typically used in sequences with <code>fork..join</code> on multiple threads running concurrently</p><p>Response item FIFO can only hold 8 items at a time</p></blockquote><p><img src="'+g+'" alt="Untitled"></p><p><img src="'+f+'" alt="Untitled"></p><h2 id="sequential-sequences" tabindex="-1">Sequential sequences <a class="header-anchor" href="#sequential-sequences" aria-label="Permalink to &quot;Sequential sequences&quot;">​</a></h2><p><img src="'+b+'" alt="Untitled"></p><blockquote><p><code>start()</code> is blocking so the <code>exec_seq</code> won’t start until the <code>init_seq</code> finish executing</p></blockquote><h2 id="parallel-sequences" tabindex="-1">Parallel sequences <a class="header-anchor" href="#parallel-sequences" aria-label="Permalink to &quot;Parallel sequences&quot;">​</a></h2><p><img src="'+_+'" alt="Untitled"></p><blockquote><p>Have to implement additional checking logic to indicate the end of the execution when using <code>fork-join_none</code> to explicitly drop the objection</p></blockquote><p><img src="'+k+'" alt="Untitled"></p><h2 id="hierarchical-sequences" tabindex="-1">Hierarchical sequences <a class="header-anchor" href="#hierarchical-sequences" aria-label="Permalink to &quot;Hierarchical sequences&quot;">​</a></h2><p><img src="'+U+'" alt="Untitled"></p><blockquote><p><code>this</code> argument specify the parent sequence of the currently starting sequence</p></blockquote><p><img src="'+v+'" alt="Untitled"></p><h2 id="pipelined-driver" tabindex="-1">Pipelined Driver <a class="header-anchor" href="#pipelined-driver" aria-label="Permalink to &quot;Pipelined Driver&quot;">​</a></h2><blockquote><p>Start another sequence before the finish of previous sequence</p></blockquote><blockquote><p>Involved calling the task multiple time in <code>fork..join</code> block</p></blockquote><p><img src="'+y+'" alt="Untitled"></p><p><img src="'+S+'" alt="Untitled"></p><blockquote><p><code>pipeline_lock.get()</code> and <code>pipeline_lock.put()</code> are the semaphore and the its methods to control the resources</p><p><code>get</code> claim the lock</p><p><code>put</code> release the lock</p></blockquote><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><p><em>Make sure to parameterize sequence/sequencer/driver with the same request and response types</em></p><p><em>Start sequences using <code>seq.start(sequencer)</code></em></p><p><em>Use <code>seq_item_port.get_next_item/item_done</code> in the driver</em></p><ul><li>Use <code>try_next_item</code>/<code>item_done</code> if driver must perform idle cycles</li><li>Use <code>get</code>/<code>put</code> for pipelined drivers</li></ul><p><em>Use API from test or parent sequence to configure sequences</em></p><p><em>Sequence and Driver must agree on response path, if any</em></p>',56)]))}const T=t(x,[["render",P]]);export{M as __pageData,T as default};
